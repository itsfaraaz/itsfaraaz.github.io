<h1 id="package-locks5">package-locks(5)</h1>

<h2 id="an-explanation-of-npm-lockfiles">An explanation of npm lockfiles</h2>

<h3 id="description">Description</h3>

<p>Conceptually, the “input” to <a href="/cli-commands/npm-install"><code class="highlighter-rouge">npm install</code></a> is a <a href="/configuring-npm/package-json">package.json</a>, while its
“output” is a fully-formed <code class="highlighter-rouge">node_modules</code> tree: a representation of the
dependencies you declared. In an ideal world, npm would work like a pure
function: the same <code class="highlighter-rouge">package.json</code> should produce the exact same <code class="highlighter-rouge">node_modules</code>
tree, any time. In some cases, this is indeed true. But in many others, npm is
unable to do this. There are multiple reasons for this:</p>

<ul>
  <li>
    <p>different versions of npm (or other package managers) may have been used to install a package, each using slightly different installation algorithms.</p>
  </li>
  <li>
    <p>a new version of a direct semver-range package may have been published since the last time your packages were installed, and thus a newer version will be used.</p>
  </li>
  <li>
    <p>A dependency of one of your dependencies may have published a new version, which will update even if you used pinned dependency specifiers (<code class="highlighter-rouge">1.2.3</code> instead of <code class="highlighter-rouge">^1.2.3</code>)</p>
  </li>
  <li>
    <p>The registry you installed from is no longer available, or allows mutation of versions (unlike the primary npm registry), and a different version of a package exists under the same version number now.</p>
  </li>
</ul>

<p>As an example, consider package A:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"A"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"version"</span><span class="p">:</span><span class="w"> </span><span class="s2">"0.1.0"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"dependencies"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"B"</span><span class="p">:</span><span class="w"> </span><span class="s2">"&lt;0.1.0"</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>package B:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"B"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"version"</span><span class="p">:</span><span class="w"> </span><span class="s2">"0.0.1"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"dependencies"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"C"</span><span class="p">:</span><span class="w"> </span><span class="s2">"&lt;0.1.0"</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>and package C:</p>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"C"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"version"</span><span class="p">:</span><span class="w"> </span><span class="s2">"0.0.1"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>If these are the only versions of A, B, and C available in the
registry, then a normal <code class="highlighter-rouge">npm install A</code> will install:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">A@</span><span class="mf">0.1</span><span class="err">.</span><span class="mi">0</span><span class="w">
</span><span class="err">`--</span><span class="w"> </span><span class="err">B@</span><span class="mf">0.0</span><span class="err">.</span><span class="mi">1</span><span class="w">
    </span><span class="err">`--</span><span class="w"> </span><span class="err">C@</span><span class="mf">0.0</span><span class="err">.</span><span class="mi">1</span><span class="w">
</span></code></pre></div></div>

<p>However, if B@0.0.2 is published, then a fresh <code class="highlighter-rouge">npm install A</code> will
install:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A@0.1.0
<span class="sb">`</span><span class="nt">--</span> B@0.0.2
    <span class="sb">`</span><span class="nt">--</span> C@0.0.1
</code></pre></div></div>

<p>assuming the new version did not modify B’s dependencies. Of course,
the new version of B could include a new version of C and any number
of new dependencies. If such changes are undesirable, the author of A
could specify a dependency on B@0.0.1. However, if A’s author and B’s
author are not the same person, there’s no way for A’s author to say
that he or she does not want to pull in newly published versions of C
when B hasn’t changed at all.</p>

<p>To prevent this potential issue, npm uses <a href="/configuring-npm/package-lock-json">package-lock.json</a> or, if present, <a href="/configuring-npm/shrinkwrap-json">npm-shrinkwrap.json</a>. These files are called package locks, or lockfiles.</p>

<p>Whenever you run <code class="highlighter-rouge">npm install</code>, npm generates or updates your package lock,
which will look something like this:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"A"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"version"</span><span class="p">:</span><span class="w"> </span><span class="s2">"0.1.0"</span><span class="p">,</span><span class="w">
  </span><span class="err">...metadata</span><span class="w"> </span><span class="err">fields...</span><span class="w">
  </span><span class="nl">"dependencies"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"B"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="nl">"version"</span><span class="p">:</span><span class="w"> </span><span class="s2">"0.0.1"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"resolved"</span><span class="p">:</span><span class="w"> </span><span class="s2">"https://registry.npmjs.org/B/-/B-0.0.1.tgz"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"integrity"</span><span class="p">:</span><span class="w"> </span><span class="s2">"sha512-DeAdb33F+"</span><span class="w">
      </span><span class="nl">"dependencies"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nl">"C"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
          </span><span class="nl">"version"</span><span class="p">:</span><span class="w"> </span><span class="s2">"git://github.com/org/C.git#5c380ae319fc4efe9e7f2d9c78b0faa588fd99b4"</span><span class="w">
        </span><span class="p">}</span><span class="w">
      </span><span class="p">}</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>This file describes an <em>exact</em>, and more importantly <em>reproducible</em>
<code class="highlighter-rouge">node_modules</code> tree. Once it’s present, any future installation will base its
work off this file, instead of recalculating dependency versions off
<a href="/configuring-npm/package-json">package.json</a>.</p>

<p>The presence of a package lock changes the installation behavior such that:</p>

<ol>
  <li>
    <p>The module tree described by the package lock is reproduced. This means
reproducing the structure described in the file, using the specific files
referenced in “resolved” if available, falling back to normal package resolution
using “version” if one isn’t.</p>
  </li>
  <li>
    <p>The tree is walked and any missing dependencies are installed in the usual
fashion.</p>
  </li>
</ol>

<p>If <code class="highlighter-rouge">preshrinkwrap</code>, <code class="highlighter-rouge">shrinkwrap</code> or <code class="highlighter-rouge">postshrinkwrap</code> are in the <code class="highlighter-rouge">scripts</code>
property of the <code class="highlighter-rouge">package.json</code>, they will be executed in order. <code class="highlighter-rouge">preshrinkwrap</code>
and <code class="highlighter-rouge">shrinkwrap</code> are executed before the shrinkwrap, <code class="highlighter-rouge">postshrinkwrap</code> is
executed afterwards. These scripts run for both <code class="highlighter-rouge">package-lock.json</code> and
<code class="highlighter-rouge">npm-shrinkwrap.json</code>. For example to run some postprocessing on the generated
file:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">  </span><span class="nl">"scripts"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"postshrinkwrap"</span><span class="p">:</span><span class="w"> </span><span class="s2">"json -I -e </span><span class="se">\"</span><span class="s2">this.myMetadata = $MY_APP_METADATA</span><span class="se">\"</span><span class="s2">"</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h4 id="using-locked-packages">Using locked packages</h4>

<p>Using a locked package is no different than using any package without a package
lock: any commands that update <code class="highlighter-rouge">node_modules</code> and/or <code class="highlighter-rouge">package.json</code>’s
dependencies will automatically sync the existing lockfile. This includes <code class="highlighter-rouge">npm
install</code>, <code class="highlighter-rouge">npm rm</code>, <code class="highlighter-rouge">npm update</code>, etc. To prevent this update from happening,
you can use the <code class="highlighter-rouge">--no-save</code> option to prevent saving altogether, or
<code class="highlighter-rouge">--no-shrinkwrap</code> to allow <code class="highlighter-rouge">package.json</code> to be updated while leaving
<code class="highlighter-rouge">package-lock.json</code> or <code class="highlighter-rouge">npm-shrinkwrap.json</code> intact.</p>

<p>It is highly recommended you commit the generated package lock to source
control: this will allow anyone else on your team, your deployments, your
CI/continuous integration, and anyone else who runs <code class="highlighter-rouge">npm install</code> in your
package source to get the exact same dependency tree that you were developing
on. Additionally, the diffs from these changes are human-readable and will
inform you of any changes npm has made to your <code class="highlighter-rouge">node_modules</code>, so you can notice
if any transitive dependencies were updated, hoisted, etc.</p>

<h4 id="resolving-lockfile-conflicts">Resolving lockfile conflicts</h4>

<p>Occasionally, two separate npm install will create package locks that cause
merge conflicts in source control systems. As of <code class="highlighter-rouge">npm@5.7.0</code>, these conflicts
can be resolved by manually fixing any <code class="highlighter-rouge">package.json</code> conflicts, and then
running <code class="highlighter-rouge">npm install [--package-lock-only]</code> again. npm will automatically
resolve any conflicts for you and write a merged package lock that includes all
the dependencies from both branches in a reasonable tree. If
<code class="highlighter-rouge">--package-lock-only</code> is provided, it will do this without also modifying your
local <code class="highlighter-rouge">node_modules/</code>.</p>

<p>To make this process seamless on git, consider installing
<a href="https://npm.im/npm-merge-driver"><code class="highlighter-rouge">npm-merge-driver</code></a>, which will teach git how
to do this itself without any user interaction. In short: <code class="highlighter-rouge">$ npx
npm-merge-driver install -g</code> will let you do this, and even works with
pre-<code class="highlighter-rouge">npm@5.7.0</code> versions of npm 5, albeit a bit more noisily. Note that if
<code class="highlighter-rouge">package.json</code> itself conflicts, you will have to resolve that by hand and run
<code class="highlighter-rouge">npm install</code> manually, even with the merge driver.</p>

<h3 id="see-also">See Also</h3>

<ul>
  <li>https://medium.com/@sdboyer/so-you-want-to-write-a-package-manager-4ae9c17d9527</li>
  <li><a href="/configuring-npm/package-json">package.json</a></li>
  <li><a href="/configuring-npm/package-lock-json">package-lock.json</a></li>
  <li><a href="/configuring-npm/shrinkwrap-json">shrinkwrap.json</a></li>
  <li><a href="/cli-commands/npm-shrinkwrap">npm shrinkwrap</a></li>
</ul>
